<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Touch-Drawn Slit-Scan Ribbon</title>
  <style>
    html,
    body {
      margin: 0;
      overflow: hidden;
      touch-action: none;
    }

    canvas#slitCanvas {
      display: none;
    }

    canvas#drawCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: auto;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <canvas id="slitCanvas"></canvas>
  <canvas id="drawCanvas"></canvas>
  <script type="module">


    // polyfill via https://jan-ivar.github.io/polyfills/mediastreamtrackprocessor.js
    if (!self.MediaStreamTrackProcessor) {
      console.log("Polyfilling MediaStreamTrackProcessor");
      self.MediaStreamTrackProcessor = class MediaStreamTrackProcessor {
        constructor({ track }) {
          if (track.kind == "video") {
            this.readable = new ReadableStream({
              async start(controller) {
                this.video = document.createElement("video");
                this.video.srcObject = new MediaStream([track]);
                await Promise.all([this.video.play(), new Promise(r => this.video.onloadedmetadata = r)]);
                this.track = track;
                this.canvas = new OffscreenCanvas(this.video.videoWidth, this.video.videoHeight);
                this.ctx = this.canvas.getContext('2d', { desynchronized: true });
                this.t1 = performance.now();
              },
              async pull(controller) {
                while (performance.now() - this.t1 < 1000 / track.getSettings().frameRate) {
                  await new Promise(r => requestAnimationFrame(r));
                }
                this.t1 = performance.now();
                this.ctx.drawImage(this.video, 0, 0);
                controller.enqueue(new VideoFrame(this.canvas, { timestamp: this.t1 }));
              }
            });
          }
        }
      };
    }


    // polyfill via https://jan-ivar.github.io/polyfills/mediastreamtrackgenerator.js

    if (!window.MediaStreamTrackGenerator) {
      console.log("Polyfilling MediaStreamTrackGenerator");
      window.MediaStreamTrackGenerator = class MediaStreamTrackGenerator {
        constructor({ kind }) {
          if (kind == "video") {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext('2d', { desynchronized: true });
            const track = canvas.captureStream().getVideoTracks()[0];
            track.writable = new WritableStream({
              write(frame) {
                canvas.width = frame.displayWidth;
                canvas.height = frame.displayHeight;
                ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
                frame.close();
              }
            });
            return track;
          }
        }
      };
    }

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const slitCanvas = document.getElementById('slitCanvas');
    const slitCtx = slitCanvas.getContext('2d');
    const drawCanvas = document.getElementById('drawCanvas');
    const drawCtx = drawCanvas.getContext('2d');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 10);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    let ribbonMesh = null;
    let ribbonTexture = null;

    function screenToWorld(x, y) {
      const ndc = new THREE.Vector2(
        (x / window.innerWidth) * 2 - 1,
        -(y / window.innerHeight) * 2 + 1
      );
      const ray = new THREE.Raycaster();
      ray.setFromCamera(ndc, camera);
      const point = new THREE.Vector3();
      ray.ray.at(5, point); // fixed Z depth
      return point;
    }

    function buildRibbonFromPoints(points, width = 1) {
      if (points.length < 2) return;

      const curve = new THREE.Curve();
      curve.getPoint = t => {
        const i = t * (points.length - 1);
        const a = Math.floor(i);
        const b = Math.min(Math.ceil(i), points.length - 1);
        const p1 = points[a];
        const p2 = points[b];
        return new THREE.Vector3().lerpVectors(p1, p2, i - a);
      };
      curve.getTangent = t => {
        const delta = 0.001;
        const p1 = curve.getPoint(Math.max(t - delta, 0));
        const p2 = curve.getPoint(Math.min(t + delta, 1));
        return p2.clone().sub(p1).normalize();
      };

      const segments = 300;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const uvs = [];
      const indices = [];

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const point = curve.getPoint(t);
        const tangent = curve.getTangent(t).normalize();
        const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
        const left = point.clone().addScaledVector(normal, -width / 2);
        const right = point.clone().addScaledVector(normal, width / 2);

        positions.push(left.x, left.y, left.z);
        positions.push(right.x, right.y, right.z);
        uvs.push(0, t);
        uvs.push(1, t);

        if (i < segments) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 1, base + 3, base + 2);
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      if (ribbonMesh) scene.remove(ribbonMesh);
      ribbonMesh = new THREE.Mesh(
        geometry,
        new THREE.MeshBasicMaterial({ map: ribbonTexture, side: THREE.DoubleSide })
      );
      scene.add(ribbonMesh);
    }

    function resizeCanvas() {
      drawCanvas.width = window.innerWidth;
      drawCanvas.height = window.innerHeight;
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const drawPoints = [];

    function startDrawing(x, y) {
      drawPoints.length = 0;
      drawPoints.push(screenToWorld(x, y));
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    }

    function addDrawing(x, y) {
      drawPoints.push(screenToWorld(x, y));
      drawCtx.lineWidth = 2;
      drawCtx.strokeStyle = 'rgba(255,255,255,0.3)';
      drawCtx.beginPath();
      for (let i = 0; i < drawPoints.length - 1; i++) {
        const a = drawPoints[i];
        const b = drawPoints[i + 1];
        const ax = (a.x / 10 + 0.5) * drawCanvas.width;
        const ay = (1 - (a.y / 10 + 0.5)) * drawCanvas.height;
        const bx = (b.x / 10 + 0.5) * drawCanvas.width;
        const by = (1 - (b.y / 10 + 0.5)) * drawCanvas.height;
        drawCtx.moveTo(ax, ay);
        drawCtx.lineTo(bx, by);
      }
      drawCtx.stroke();
    }

    function endDrawing() {
      if (drawPoints.length >= 2) {
        buildRibbonFromPoints(drawPoints);
      }
    }

    // Mouse + Touch Events
    drawCanvas.addEventListener('pointerdown', e => {
      startDrawing(e.clientX, e.clientY);
      drawCanvas.setPointerCapture(e.pointerId);
    });
    drawCanvas.addEventListener('pointermove', e => {
      if (e.buttons === 1) addDrawing(e.clientX, e.clientY);
    });
    drawCanvas.addEventListener('pointerup', e => {
      endDrawing();
    });

    const tryResolutions = async () => {
      const baseConstraints = { facingMode: { ideal: "environment" } };
      const resolutions = [
        { width: 160, height: 120 },
        { width: 320, height: 240 },
        { width: 640, height: 480 }
      ];
      for (const res of resolutions) {
        try {
          return await navigator.mediaDevices.getUserMedia({
            video: {
              ...baseConstraints,
              width: { exact: res.width },
              height: { exact: res.height }
            }
          });
        } catch { }
      }
      return navigator.mediaDevices.getUserMedia({ video: baseConstraints });
    };

    const startSlitScan = async () => {
      const stream = await tryResolutions();
      const track = stream.getVideoTracks()[0];
      const processor = new MediaStreamTrackProcessor({ track });
      const reader = processor.readable.getReader();

      const { value: firstFrame } = await reader.read();
      const videoWidth = firstFrame.displayWidth;
      const videoHeight = firstFrame.displayHeight;

      slitCanvas.width = videoWidth;
      slitCanvas.height = 512;
      let row = 0;

      const processFrame = async (frame) => {
        const bitmap = await createImageBitmap(frame);
        const tmp = new OffscreenCanvas(videoWidth, videoHeight);
        const tmpCtx = tmp.getContext('2d');
        tmpCtx.drawImage(bitmap, 0, 0);
        const midY = Math.floor(videoHeight / 2);
        const imageData = tmpCtx.getImageData(0, midY, videoWidth, 1);
        slitCtx.putImageData(imageData, 0, row);
        frame.close();
        row = (row + 1) % slitCanvas.height;
      };

      await processFrame(firstFrame);

      ribbonTexture = new THREE.CanvasTexture(slitCanvas);
      ribbonTexture.wrapS = THREE.RepeatWrapping;
      ribbonTexture.wrapT = THREE.RepeatWrapping;
      ribbonTexture.minFilter = THREE.LinearFilter;
      ribbonTexture.center.set(0.5, 0.5);
      ribbonTexture.rotation = Math.PI;

      const renderLoop = () => {
        requestAnimationFrame(renderLoop);
        controls.update();
        renderer.render(scene, camera);
      };

      const animateSlit = async () => {
        while (true) {
          const { done, value: frame } = await reader.read();
          if (done) break;
          await processFrame(frame);
          ribbonTexture.needsUpdate = true;
        }
      };

      renderLoop();
      animateSlit();
    };

    startSlitScan();
  </script>
</body>

</html>